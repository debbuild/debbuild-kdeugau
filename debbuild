#!/usr/bin/perl -w
# debbuild script
# Shamelessly steals interface from rpm's "rpmbuild" to create
# Debian packages.  Please note that such packages are highly
# unlikely to conform to "Debian Policy".
###
# SVN revision info
# $Date$
# SVN revision $Rev$
# Last update by $Author$
###
# Copyright 2005-2007 Kris Deugau <kdeugau@deepnet.cx>
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA

use strict;
use warnings;
use Fcntl;	# for sysopen flags
use Cwd 'abs_path';	# for finding where files really are

# regex debugger
#use re "debug";

# Program flow:
# -> Parse/execute "system" config/macros (if any - should be rare)
# -> Parse/execute "user" config/macros (if any - *my* requirement is %_topdir)
# -> Parse command line for options, spec file/tarball/.src.deb (NB - also accept .src.rpm)

sub expandmacros;

# User's prefs for dirs, environment, etc,etc,etc.
# config file ~/.debmacros
# Default ordered search paths for config/macros:
# /usr/lib/rpm/rpmrc  /usr/lib/rpm/redhat/rpmrc  /etc/rpmrc      ~/.rpmrc
# /usr/lib/rpm/macros /usr/lib/rpm/redhat/macros /etc/rpm/macros ~/.rpmmacros
# **NOTE:  May be possible to (ab)use bits of debhelper

# Build tree
# default is /usr/src/debian/{BUILD,SOURCES,SPECS,DEBS,SDEBS}

# Globals
my $finalmessages = '';	# A place to stuff messages that I want printed at the *very* end of any processing.
my $specfile;
my $tarball;
my $srcpkg;
my $cmdbuildroot;
my $tarballdir; = '%{name}-%{version}';	# We do this in case of a spec file not using %setup...
my %specglobals;	# For %define's in specfile, among other things.

# Initialized globals
my $verbosity = 0;
my %cmdopts = (type => '',
		stage => 'a',
		short => 'n'
	);
my $topdir = "/usr/src/debian";
my $buildroot = "%{_tmppath}/%{name}-%{version}-%{release}.root".int(rand(99998)+1);

# "Constants"
my %targets = ('p' => 'Prep',
		'c' => 'Compile',
		'i' => 'Install',
		'l' => 'Verify %files',
		'a' => 'Build binary and source',
		'b' => 'Build binary',
		's' => 'Build source'
	);
# Ah, the joys of multiple architectures.  :(  Feh.
# As copied from rpm
my %optflags = ( 'i386'	=>	'-O2 -g -march=i386 -mcpu=i686',
		'amd64'	=>	'-O2 -g'
	);
my $hostarch;	# we set this later...
my $scriptletbase =
q(#!/bin/sh

  RPM_SOURCE_DIR="%{_topdir}/SOURCES"
  RPM_BUILD_DIR="%{_topdir}/BUILD"
  RPM_OPT_FLAGS="%{optflags}"
  RPM_ARCH="%{_arch}"
  RPM_OS="linux"
  export RPM_SOURCE_DIR RPM_BUILD_DIR RPM_OPT_FLAGS RPM_ARCH RPM_OS
  RPM_DOC_DIR="/usr/share/doc"
  export RPM_DOC_DIR
  RPM_PACKAGE_NAME="%{name}"
  RPM_PACKAGE_VERSION="%{version}"
  RPM_PACKAGE_RELEASE="%{release}"
  export RPM_PACKAGE_NAME RPM_PACKAGE_VERSION RPM_PACKAGE_RELEASE
  RPM_BUILD_ROOT="%{buildroot}"
  export RPM_BUILD_ROOT
);
foreach (`dpkg-architecture`) {
  s/=(.+)/="$1"/;
  $scriptletbase .= "  $_";
  ($hostarch) = (/^DEB_HOST_ARCH="(.+)"$/) if /DEB_HOST_ARCH=/;
}
$scriptletbase .=
q(
  set -x
  umask 022
  cd %{_topdir}/BUILD
);

# Package data
# This is the form of $pkgdata{pkgname}{meta}
# meta includes Summary, Name, Version, Release, Group, Copyright,
#	Source, URL, Packager, BuildRoot, Description, BuildReq(uires),
#	Requires, Provides
# 10/31/2005 Maybe this should be flatter?  -kgd
my %pkgdata;
my @pkglist = ('main');	#sigh
# Files listing.  Embedding this in %pkgdata would be, um, messy.
my %filelist;
my $buildreq = '';

# Scriptlets
my $prepscript = '';
my $buildscript = '';
# %install doesn't need the full treatment from %clean;  just an empty place to install to.
# NB - rpm doesn't do this;  is it really necessary?
my $installscript = '[ "$RPM_BUILD_ROOT" != "/" ] && rm -rf $RPM_BUILD_ROOT'."\n";
my $cleanscript = '';

die "Not enough arguments\n" if #$argv == 0;

# Snag some environment data
my $tmpdir;
if (defined $ENV{TMP} && $ENV{TMP} =~ /^(\/var)?\/tmp$/) {
  $tmpdir = $ENV{TMP};
} else {
  $tmpdir = "/var/tmp";
}

##main

load_userconfig();
parse_cmd();

if ($cmdopts{install}) {
  install_sdeb();
  exit 0;
}

# output stage of --showpkgs
if ($cmdopts{type} eq 'd') {
  parse_spec();
  foreach my $pkg (@pkglist) {
    $pkgdata{$pkg}{name} =~ tr/_/-/;

    my $pkgfullname = "$pkgdata{$pkg}{name}_$pkgdata{$pkg}{version}-$pkgdata{main}{release}_$pkgdata{$pkg}{arch}.deb";

    print "$pkgfullname\n" if $filelist{$pkg};

  }
  # Source package
  print "$pkgdata{main}{name}-$pkgdata{main}{version}-$pkgdata{main}{release}.sdeb\n";
  exit 0;
}

# Stick --rebuild handling in here - basically install_sdeb()
# followed by tweaking options to run with -ba
if ($cmdopts{type} eq 's') {
  if ($srcpkg =~ /\.src\.rpm$/) {
    my @srclist = qx { rpm -qlp $srcpkg };
    foreach (@srclist) {
      chomp;
      $specfile = "$topdir/SPECS/$_" if /\.spec$/;
    }
    qx { rpm -i $srcpkg };
  } else {
    install_sdeb();
    my @srclist = qx { pax < $srcpkg };
    foreach (@srclist) {
      chomp;
      $specfile = "$topdir/$_" if /SPECS/;
    }
  }
  $cmdopts{type} = 'b';
  $cmdopts{stage} = 'a';
}

if ($cmdopts{type} eq 'b') {
  # Need to read the spec file to find the tarball.  Note that
  # this also generates most of the shell script required.
  parse_spec();
  die "Can't build $pkgdata{main}{name}:  build requirements not met.\n"
    if !checkbuildreq();
}

if ($cmdopts{type} eq 't') {
  # Need to unpack the tarball to find the spec file.  Sort of the inverse of -b above.
  # zcat $tarball |tar -t |grep .spec
  # collect some info about the tarball
  $specfile = "$topdir/BUILD/". qx { zcat $tarball |tar -t |grep .spec\$ };
  chomp $specfile;
  my ($fileonly, $dirname) = ($tarball =~ /(([a-zA-Z0-9._-]+)\.tar\.(?:gz|bz2))$/);

  $tarball = abs_path($tarball);
  my $unpackcmd = "cd $topdir/BUILD; tar -".
	( $tarball =~ /\.tar\.gz$/ ? "z" : "" ).
	( $tarball =~ /\.tar\.bz2$/ ? "j" : "" ). "xf $tarball";
  system "$unpackcmd";
  system "cp $tarball $topdir/SOURCES/$fileonly";
  system "cp $specfile $topdir/SPECS/";
  parse_spec();
  die "Can't build $pkgdata{main}{name}:  build requirements not met.\n"
    if !checkbuildreq();
}

# -> srcpkg if -.s
if ($cmdopts{stage} eq 's') {
  srcpackage();
  exit 0;
}

# Hokay.  Need to:
# -> prep if -.p OR (-.[cilabs] AND !--short-circuit)
if ($cmdopts{stage} eq 'p' || ($cmdopts{stage} =~ /[cilabs]/ && $cmdopts{short} ne 'y')) {
  prep();
}
# -> build if -.c OR (-.[ilabs] AND !--short-circuit)
if ($cmdopts{stage} eq 'c' || ($cmdopts{stage} =~ /[ilabs]/ && $cmdopts{short} ne 'y')) {
  build();
}
# -> install if -.[ilabs]
#if ($cmdopts{stage} eq 'i' || ($cmdopts{stage} =~ /[labs]/ && $cmdopts{short} ne 'y')) {
if ($cmdopts{stage} =~ /[ilabs]/) {
  install();
#foreach my $pkg (@pkglist) {
#  print "files in $pkg:\n ".$filelist{$pkg}."\n";
#}

}
# -> binpkg and srcpkg if -.a
if ($cmdopts{stage} eq 'a') {
  binpackage();
  srcpackage();
}
# -> binpkg if -.b
if ($cmdopts{stage} eq 'b') {
  binpackage();
}

# Spit out any closing remarks
print $finalmessages;

# Just in case.
exit 0;


## load_userconfig()
# Loads user configuration (if any)
# Currently only handles .debmacros
# Needs to handle "other files"
sub load_userconfig {
  my (undef,undef,undef,undef,undef,undef,undef,$homedir,undef) = getpwuid($<);
  if (-e "$homedir/.debmacros") {
    open USERMACROS,"<$homedir/.debmacros";
    while (<USERMACROS>) {
      # And we also only handle a few macros at the moment.
      if (/^\%_topdir/) {
	my (undef,$tmp) = split /\s+/, $_;
	$topdir = $tmp;
      }
    }
  }
} # end load_userconfig()


## parse_cmd()
# Parses command line into global hash %cmdopts, other globals
# Options based on rpmbuild's options
sub parse_cmd {
  # Don't feel like coding my own option parser...
  #use Getopt::Long;
  # ... but I may have to:  (OTOH, rpm uses popt, so maybe we can too.)
  #use Getopt::Popt qw(:all);
  # Or not.  >:(  Stupid Debian lack of findable Perl module names in packages.

  # Stuff it.
  my $prevopt = '';
  foreach (@ARGV) {
    chomp;

    # Is it an option?
    if (/^-/) {

      # Is it a long option?
      if (/^--/) {
	if (/^--short-circuit/) {
	  $cmdopts{short} = 'y';
	} elsif (/^--rebuild/) {
	  $cmdopts{type} = 's';
	} elsif (/^--showpkgs/) {
	  $cmdopts{type} = 'd';	# d for 'diagnostic' or 'debug' or 'dump'
	} elsif (/^--define/) {
	  # nothing to do?  Can't see anything needed, we handle the actual definition later.
	} else {
	  print "Long option $_ not handled\n";
	}
      } else {
	# Not a long option
	if (/^-[bt]/) {
	  if ($cmdopts{stage} eq 's') {
	    # Mutually exclusive options.
	    die "Can't use $_ with --rebuild\n";
	  } else {
	    # Capture the type (from "bare" files or tarball) and the stage (prep, build, etc)
	    ($cmdopts{stage}) = (/^-[bt]([pcilabs])/);
	    ($cmdopts{type}) = (/^-([bt])[pcilabs]/);
	  }
	} elsif (/^-v/) {
	  # bump verbosity.  Not sure what I'll actually do here...
	} elsif (/^-i/) {
	  $cmdopts{install} = 1;
	  $prevopt = '-i';
	} else {
	  die "Bad option $_\n";
	}
      }

    } else { # Not an option argument

      # --buildroot is the only option that takes an argument
      # Therefore, any *other* bare arguments are the spec file,
      # tarball, or source package we're operating on - depending
      # on which one we meet.
      if ($prevopt eq '--buildroot') {
	$cmdbuildroot = $_;
      } elsif ($prevopt eq '--define') {
	my ($macro,$value) = (/([a-z0-9_.-]+)(?:\s+(.+))?/);
	if ($value) {
	  $specglobals{$macro} = $value;
	} else {
	  warn "WARNING:  missing value for macro $macro in --define!  Ignoring.\n";
	}
      } elsif ($prevopt eq '-i') {
	$srcpkg = $_;
      } else {
	if ($cmdopts{type} eq 's') {
	  # Source package
 	  if (!/(sdeb|\.src\.rpm)$/) {
	    die "Can't --rebuild with $_\n";
	  }
          $srcpkg = $_;
	} elsif ($cmdopts{type} eq 'b' || $cmdopts{type} eq 'd') {
	  # Spec file
	  $specfile = $_;
	} else {
	  # Tarball build.  Need to extract tarball to find spec file.  Whee.
	  $tarball = $_;
	}
      }
    }
    $prevopt = $_;
  } # foreach @ARGV

  # Some cross-checks.  rpmbuild limits --short-circuit to just
  # the "compile" and "install" targets - with good reason IMO.
  # Note that --short-circuit with -.p is not really an error, just redundant.
  # NB - this is NOT fatal, just ignored!
  if ($cmdopts{short} eq 'y' && $cmdopts{stage} =~ /[labs]/) {
    warn "Can't use --short-circuit for $targets{$cmdopts{stage}} stage.  Ignoring.\n";
    $cmdopts{short} = 'n';
  }

  # Valid options, with example arguments (if any):
# Build from .spec file; mutually exclusive:
  # -bp
  # -bc         
  # -bi         
  # -bl
  # -ba
  # -bb
  # -bs
# Build from tarball; mutually exclusive:
  # -tp
  # -tc
  # -ti
  # -ta
  # -tb
  # -ts
# Build from .src.(deb|rpm)
  # --rebuild
  # --recompile

# General options
  # --buildroot=DIRECTORY
  # --clean
  # --nobuild
  # --nodeps
  # --nodirtokens
  # --rmsource
  # --rmspec
  # --short-circuit
  # --target=CPU-VENDOR-OS

  #my $popt = new Getopt::Popt(argv => \@ARGV, options => \@optionsTable);

} # end parse_cmd()


## parse_spec()
# Parse the .spec file.
sub parse_spec {
  open SPECFILE,"<$specfile" or die "specfile ($specfile) barfed: $!";

  my $buildarch = $hostarch;
  $pkgdata{main}{arch} = $hostarch;

LINE: while (<SPECFILE>) {
    next if /^#/;	# Ignore comments...
    next if /^\s*$/;	# ... and blank lines.

    if (/^\%/) {
      # A macro that needs further processing.

      if (my ($key, $def) = (/^\%define\s+([^\s]+)\s+(.+)$/) ) {
        $specglobals{$key} = expandmacros($def,'g');
      }

      if (/^\%description(?:\s+(?:-n\s+)?(.+))?/) {
	my $subname = "main";
	if ($1) {
	  my $tmp = expandmacros("$1", 'g');
	  if (/-n/) { $subname = $tmp; } else { $subname = "$pkgdata{main}{name}-$tmp"; }
	}
        while (<SPECFILE>) {
	  next if /^#/;    # Messy.  Should be possible to do better.  :/
          redo LINE if /^\%/;
          $pkgdata{$subname}{desc} .= " $_";
        }
      }
      if (/^\%package\s+(?:-n\s+)?(.+)/) {
	# gotta expand %defines here.  Whee.
	my $subname = expandmacros("$1", 'g');
	if (! /-n/) { $subname = "$pkgdata{main}{name}-$1"; }
	push @pkglist, $subname;
	$pkgdata{$subname}{name} = $subname;
	$pkgdata{$subname}{version} = $pkgdata{main}{version};
  # Build "same arch as previous package found" by default.  Where rpm just picks the
  # *very* last one, we want to allow arch<native>+arch-all
  # (eg, Apache is i386, but apache-manual is all)
	$pkgdata{$subname}{arch} = $buildarch;	# Since it's likely subpackages will NOT have a BuildArch line...
	while (<SPECFILE>) {
	  redo LINE if /^\%/;
	  if (my ($dname,$dvalue) = (/^(Summary|Group|Version|Requires|Provides|BuildArch(?:itecture)?):\s+(.+)$/i)) {
	    $dname =~ tr/[A-Z]/[a-z]/;
	    if ($dname =~ /^BuildArch/i) {
	      $dvalue =~ s/^noarch/all/ig;
	      $buildarch = $dvalue;	# Emulate rpm's behaviour to a degree
	      $dname = 'arch';
	    }
	    $pkgdata{$subname}{$dname} = expandmacros($dvalue, 'gp');
	  }
	}
      }

      if (/^\%prep/) {
	# %prep section.  May have %setup macro;  may include %patch tags,
	# may be just a bare shell script.

	# This really should be local-ish, but we need just the filename for the source
	$pkgdata{main}{source} =~ s|.+/([^/]+)$|$1|;

	# Replace some core macros
	$pkgdata{main}{source} = expandmacros($pkgdata{main}{source},'gp');

PREPSCRIPT: while (<SPECFILE>) {
	  if (/^\%setup/) {
	    # Parse out the %setup macro.  Note that we aren't supporting
	    # many of RPM's %setup features.
	    $prepscript .= "cd $topdir/BUILD\n";
	    if ( /\s+-n\s+([^\s]+)\s+/ ) {
	      $tarballdir = $1;
	    }
	    $tarballdir = expandmacros($tarballdir,'gp');
	    $prepscript .= "rm -rf $tarballdir\n";
	    if (/\s+-c\s+/) {
	      $prepscript .= "mkdir $tarballdir\ncd $tarballdir\n";
	    }
	    $prepscript .= "tar -".
		( $pkgdata{main}{source} =~ /\.tar\.gz$/ ? "z" : "" ).
		( $pkgdata{main}{source} =~ /\.tar\.bz2$/ ? "j" : "" ).
		( /\s+-q\s+/ ? '' : 'vv' )."xf ".
		"$topdir/SOURCES/$pkgdata{main}{source}\n".
		qq(STATUS=\$?\nif [ \$STATUS -ne 0 ]; then\n  exit \$STATUS\nfi\n).
		"cd $topdir/BUILD/$tarballdir\n".
		qq([ `/usr/bin/id -u` = '0' ] && /bin/chown -Rhf root .\n).
		qq([ `/usr/bin/id -u` = '0' ] && /bin/chgrp -Rhf root .\n).
		qq(/bin/chmod -Rf a+rX,g-w,o-w .\n);
	  } elsif ( my ($patchnum,$patchopts) = (/^\%patch([^\s]+)(\s+.+)?$/) ) {
	    chomp $patchnum;
	    $prepscript .= qq(echo "Patch #$patchnum ($pkgdata{main}{"patch$patchnum"}):"\n).
		"patch ";
	# If there are options passed, use'em.
	# Otherwise, catch a bare %patch and ASS-U-ME it's '-p0'-able.
	# Will break on options that don't provide -pnn, but what the hell.
            $prepscript .= $patchopts if $patchopts;
	    $prepscript .= "-p0" if !$patchopts;
	    $prepscript .= " -s <$topdir/SOURCES/".$pkgdata{main}{"patch$patchnum"}."\n";
	  } else {
	    last PREPSCRIPT if /^\%/;
	    $prepscript .= $_;
	  }
	}
	redo LINE;
      }
      if (/^\%build/) {
	# %build.  This is pretty much just a shell script.  There
	# *are* a few macros, but we're not going to deal with them yet.
	$buildscript .= "cd $tarballdir\n";
BUILDSCRIPT: while (<SPECFILE>) {
	  if (/^\%configure/) {
	    $buildscript .= expandmacros($_,'cgbp');
	  } elsif (/^\%\{__make\}/) {
	    $buildscript .= expandmacros($_,'mgbp');
	  } else {
	    last BUILDSCRIPT if /^\%[^{]/;
	    $buildscript .= $_;
	  }
	}
	redo LINE;
      }
      if (/^\%install/) {
	$installscript .= "cd $tarballdir\n";
INSTALLSCRIPT: while (<SPECFILE>) {
	  if (/^\%makeinstall/) {
            $installscript .= expandmacros($_,'igbp');
          } else {
            last INSTALLSCRIPT if /^\%/;
            $installscript .= $_;
          }
        }
	redo LINE;
      }
      if (/^\%clean/) {
	while (<SPECFILE>) {
	  redo LINE if /^\%/;
	  $cleanscript .= $_;
	}
	$cleanscript = expandmacros($cleanscript,'gp');
      }

    # pre/post (un)install scripts.  Note that we expand macros later anyway, so we'll leave them unexpanded here.
      if (/^\%(pre|post|preun|postun)\b(?:\s+(?:-n\s+)?(.+))?/i) {
	my $scriptlet = lc $1;
	my $pkgname = 'main';
	if ($2) {	# Magic to add entries to the right list of files
	  my $tmp = expandmacros("$2", 'g');
	  if (/-n/) { $pkgname = $tmp; } else { $pkgname = "$pkgdata{main}{name}-$tmp"; }
	}
	while (<SPECFILE>) {
	  redo LINE if /^\%/;
	  $pkgdata{$pkgname}{$scriptlet} .= $_;
	}
      }
    # done %pre/%post scripts

      if (/^\%files(?:\s+(?:-n\s+)?(.+))?/) {
	my $pkgname = 'main';
	if ($1) {	# Magic to add entries to the right list of files
	  my $tmp = expandmacros("$1", 'g');
	  if (/-n/) { $pkgname = $tmp; } else { $pkgname = "$pkgdata{main}{name}-$tmp"; }
	}

	# Set this now, so it can be flipped a bit later, and used much later.
	#$pkgdata{$pkgname}{conffiles} = 0;

	while (<SPECFILE>) {
	  chomp;
	  next if /^#/;
	  # need to update this to deal (properly) with %dir, %attr, etc
	  next if /^\%dir/;
	  next if /^\%defattr/;

	  # Debian dpkg doesn't speak "%docdir".  Meh.
	  next if /^\%docdir/;

##fixme
# Note that big chunks of this section don't match rpm's behaviour;  among other things,
# rpm accepts more than one %-directive on one line for a file or set of files.
	  # make sure files get suitable permissions and so on
	  if (/^\%attr/) {
	    # We're going to collapse whitespace before processing.  PTHBT.
	    # While this breaks pathnames with spaces, anyone expecting command-line
	    # tools with spaces to work (never mind work *properly* or *well*) under
	    # any *nix has their head so far up their ass they can see out their mouth.
	    my ($args,$filelist) = split /\)/;
	    $filelist{$pkgname} .= " $filelist";
	    $args =~ s/\s+//g;
	    $args =~ s/"//g;	# don't think quotes are ever necessary, but they're *allowed*
	    my ($perms,$owner,$group) = ($args =~ /\(([\d-]+),([a-zA-Z0-9-]+),([a-zA-Z0-9-]+)/);
# due to Debian's total lack of real permissions-processing in its actual package
# handling component (dpkg-deb), this can't really be done "properly".  We'll have
# to add chown/chmod commands to the postinst instead.  Feh.
	    $pkgdata{$pkgname}{'post'} .= "chown $owner $filelist\n" if $owner ne '-';
	    $pkgdata{$pkgname}{'post'} .= "chgrp $group $filelist\n" if $group ne '-';
	    $pkgdata{$pkgname}{'post'} .= "chmod $perms $filelist\n" if $perms ne '-';
	    next;
	  }

	  # %doc needs extra processing, because it can be a space-separated list.
	  if (/^\%doc/) {
	    s/^\%doc\s+//;
	    foreach (split()) {
	      $filelist{$pkgname} .= " %{_docdir}/$_";
	    }
	    next;
	  }

	  # Conffiles.  Note that Debian and RH have similar, but not
	  # *quite* identical ideas of what constitutes a conffile.  Nrgh.
	  if (/^\%config\s+(.+)$/) {
	    $pkgdata{$pkgname}{conffiles} = 1;	# Flag it for later
	    my $tmp = $1;	# Now we can mangleificationate it.  And we probably need to.  :/
	    $tmp = expandmacros($tmp, 'gp');  # Expand common macros
	    if ($tmp !~ /\s+/) {
	      # Simplest case, just a file.  Whew.
	      push @{$pkgdata{$pkgname}{conflist}}, $tmp;
	      $filelist{$pkgname} .= " $tmp";
	    } else {
	      # Wot?  Spaces?  That means extra %-macros.  Which, for the most part, can be ignored.
	      ($tmp) = ($tmp =~ /.+\s([^\s]+)/);  # Strip everything before the last space
	      push @{$pkgdata{$pkgname}{conflist}}, $tmp;
	      $filelist{$pkgname} .= " $tmp";
	    }
	    next;
	  }

	  # and finally we can fall through %{_<FHS>}-prefixed locations...
	  if (/^\%\{_/) {
	    $filelist{$pkgname} .= " $_";
	    next;
	  }
	# EW.  Necessary to clear up %define expansions before we exit with redo.
	  $_ = expandmacros $_, 'g';

	  # ... unknown or "next section" % directives ...
	  redo LINE if /^\%/;

	  # ... and "normal" files
	  $filelist{$pkgname} .= " $_";
	}
      } # done %file section

      if (/^\%changelog/) {
	$pkgdata{main}{changelog} = '';
	while (<SPECFILE>) {
	  redo LINE if /^\%/;
	  $pkgdata{main}{changelog} .= $_;
	}
      }
# don't add any segments after this (%changelog), because something in the (Perl) parser gets
# thoroughly confuzzled if it tries to manipulate file data after EOL.  Feh.

    } else {	# Data from the spec file "header"

      if (/^summary:\s+(.+)/i) {
	$pkgdata{main}{summary} = $1;
      } elsif (/^name:\s+(.+)/i) {
	$pkgdata{main}{name} = expandmacros($1,'g');
      } elsif (/^version:\s+(.+)/i) {
	$pkgdata{main}{version} = expandmacros($1,'g');
      } elsif (/^release:\s+(.+)/i) {
	$pkgdata{main}{release} = expandmacros($1,'g');
      } elsif (/^group:\s+(.+)/i) {
	$pkgdata{main}{group} = $1;
      } elsif (/^copyright:\s+(.+)/i) {
	$pkgdata{main}{copyright} = $1;
      } elsif (/^url:\s+(.+)/i) {
	$pkgdata{main}{url} = $1;
      } elsif (/^packager:\s+(.+)/i) {
	$pkgdata{main}{packager} = $1;
      } elsif (/^buildroot:\s+(.+)/i) {
	$buildroot = $1;
      } elsif (/^source0?:\s+(.+)/i) {
	$pkgdata{main}{source} = $1;
	die "Unknown tarball format $1\n" if $1 !~ /\.tar\.(?:gz|bz2)$/;
      } elsif (/^source([0-9]+):\s+(.+)/i) {
	$pkgdata{sources}{$1} = $2;
      } elsif (/^patch([^:]+):\s+(.+)$/i) {
	my $patchname = "patch$1";
	$pkgdata{main}{$patchname} = $2;
	if ($pkgdata{main}{$patchname} =~ /\//) {
	  # URL-style patch.  Rare but not unheard-of.
	  my @patchbits = split '/', $pkgdata{main}{$patchname};
	  $pkgdata{main}{$patchname} = $patchbits[$#patchbits];
	}
	chomp $pkgdata{main}{$patchname};
      } elsif (/^buildarch(?:itecture)?:\s+(.+)/i) {
	$pkgdata{main}{arch} = $1;
	$pkgdata{main}{arch} =~ s/^noarch$/all/;
	$buildarch = $pkgdata{main}{arch};
      } elsif (/^buildreq(?:uires)?:\s+(.+)/i) {
	$buildreq .= ", $1";
      } elsif (/^requires:\s+(.+)/i) {
	$pkgdata{main}{requires} .= ", ".expandmacros("$1", 'gp');
      } elsif (/^provides:\s+(.+)/i) {
	$pkgdata{main}{provides} .= ", $1";
      } elsif (/^conflicts:\s+(.+)/i) {
	$pkgdata{main}{conflicts} .= ", $1";
      }
#Name: suwrap
#Version: 0.04
#Release: 3
#Group: Applications/System
#Copyright: WebHart internal ONLY.  :(
#BuildArchitectures: i386
#BuildRoot: /tmp/%{name}-%{version}
#Url: http://virtual.webhart.net
#Packager: Kris Deugau <kdeugau@deepnet.cx>
#Source: ftp://virtual.webhart.net/%{name}-%{version}.tar.gz

    }
  }

  # Parse and replace some more macros.  More will be replaced even later.

  # Expand macros as necessary.
  $scriptletbase = expandmacros($scriptletbase,'gp');

  $buildroot = $cmdbuildroot if $cmdbuildroot;
  $buildroot = expandmacros($buildroot,'gp');

  close SPECFILE;
} # end parse_spec()


## prep()
# Writes and executes the %prep script (mostly) built while reading the spec file.
sub prep {
  # Replace some things here just to make sure.
  $prepscript = expandmacros($prepscript,'gp');

  # create script filename
  my $prepscriptfile = "$tmpdir/deb-tmp.prep.".int(rand(99998)+1);
  sysopen(PREPSCRIPT, $prepscriptfile, O_RDWR | O_CREAT | O_EXCL | O_NOFOLLOW)
	or die $!;
  print PREPSCRIPT $scriptletbase;
  print PREPSCRIPT $prepscript;
  close PREPSCRIPT;

  # execute
  print "Calling \%prep script $prepscriptfile...\n";
  system("/bin/sh -e $prepscriptfile") == 0
	or die "Can't exec: $!\n";

  # and clean up
  unlink $prepscriptfile;
} # end prep()


## build()
# Writes and executes the %build script (mostly) built while reading the spec file.
sub build {
  # Expand the macros
  $buildscript = expandmacros($buildscript,'cgbp');

  # create script filename
  my $buildscriptfile = "$tmpdir/deb-tmp.build.".int(rand(99998)+1);
  sysopen(BUILDSCRIPT, $buildscriptfile, O_RDWR | O_CREAT | O_EXCL | O_NOFOLLOW)
	or die $!;
  print BUILDSCRIPT $scriptletbase;
  print BUILDSCRIPT $buildscript;
  close BUILDSCRIPT;

  # execute
  print "Calling \%build script $buildscriptfile...\n";
  system("/bin/sh -e $buildscriptfile") == 0
	or die "Can't exec: $!\n";

  # and clean up
  unlink $buildscriptfile;
} # end build()


## install()
# Writes and executes the %install script (mostly) built while reading the spec file.
sub install {
  # Expand the macros
  $installscript = expandmacros($installscript,'igbp');

  # create script filename
  my $installscriptfile = "$tmpdir/deb-tmp.inst.".int(rand(99998)+1);
  sysopen(INSTSCRIPT, $installscriptfile, O_RDWR | O_CREAT | O_EXCL | O_NOFOLLOW)
	or die $!;
  print INSTSCRIPT $scriptletbase;
  print INSTSCRIPT $installscript;
  close INSTSCRIPT;

  # execute
  print "Calling \%install script $installscriptfile...\n";
  system("/bin/sh -e $installscriptfile") == 0
	or die "Can't exec: $!\n";

  # and clean up
  unlink $installscriptfile;
} # end install()


## binpackage()
# Creates the binary .deb package from the installed tree in $buildroot.
# Writes and executes a shell script to do so.
# Creates miscellaneous files required by dpkg-deb to actually build the package file.
# Should handle simple subpackages
sub binpackage {

  foreach my $pkg (@pkglist) {

    $pkgdata{$pkg}{arch} = $hostarch if !$pkgdata{$pkg}{arch};  # Just In Case.

    # Make sure we have somewhere to write the .deb file
    if (!-e "$topdir/DEBS/$pkgdata{$pkg}{arch}") {
      mkdir "$topdir/DEBS/$pkgdata{$pkg}{arch}";
    }

    # Skip building a package if it doesn't actually have any files.  NB:  This
    # differs slightly from rpm's behaviour where a package *will* be built -
    # even without any files - if %files is specified anywhere.  I can think
    # of odd corner cases where that *may* be desireable.
    next if (!$filelist{$pkg} or $filelist{$pkg} =~ /^\s*$/);

    # Gotta do this first, otherwise we don't have a place to move files from %files
    mkdir "$buildroot/$pkg";

    # Eliminate any lingering % macros
    $filelist{$pkg} = expandmacros $filelist{$pkg}, 'g';

    my @pkgfilelist = split ' ', $filelist{$pkg};
    foreach my $pkgfile (@pkgfilelist) {
      $pkgfile = expandmacros($pkgfile, 'gp');
      my ($fpath,$fname) = ($pkgfile =~ m|(.+?/?)?([^/]+)$|);	# We don't need $fname now, but we might.
      qx { mkdir -p $buildroot/$pkg$fpath }
	if $fpath && $fpath ne '';
      qx { mv $buildroot$pkgfile $buildroot/$pkg$fpath };
    }

    # Get the "Depends" (Requires) a la RPM.  Ish.  We strip the leading
    # comma and space here (if needed) in case there were "Requires" specified
    # in the spec file - those would precede these.
    $pkgdata{$pkg}{requires} .= getreqs("$buildroot/$pkg");

    # magic needed to properly version dependencies...
    # only provided deps will really be included
    $pkgdata{$pkg}{requires} =~ s/^, //;	# Still have to do this here.
    $pkgdata{$pkg}{requires} =~ s/\s+//g;
    my @deps = split /,/, $pkgdata{$pkg}{requires};
    my $tmp = '';
    foreach my $dep (@deps) {
      # Hack up the perl(Class::SubClass) deps into something dpkg can understand.
      # May or may not be versioned.
      # We do this first so the version rewriter can do its magic next.
      if (my ($mod,$ver) = ($dep =~ /^perl\(([A-Za-z0-9\:\-]+)\)([><=]+.+)?/) ) {
	$mod =~ s/^perl\(//;
	$mod =~ s/\)$//;
	$mod =~ s/::/-/g;
	$mod =~ tr/A-Z/a-z/;
	$mod = "lib$mod-perl";
	$mod .= $ver if $ver;
	$dep = $mod;
      }
      if (my ($name,$rel,$value) = ($dep =~ /^([a-zA-Z0-9._-]+)([><=]+)([a-zA-Z0-9._-]+)$/)) {
        $tmp .= ", $name ($rel $value)";
      } else {
        $tmp .= ", $dep";
      }
    }
    ($pkgdata{$pkg}{requires} = $tmp) =~ s/^, //;

    # Do this here since we're doing {depends}...
    if (defined($pkgdata{$pkg}{provides})) {
      $pkgdata{$pkg}{provides} =~ s/^, //;
      $pkgdata{$pkg}{provides} = expandmacros($pkgdata{$pkg}{provides},'gp');
    }
    if (defined($pkgdata{$pkg}{conflicts})) {
      $pkgdata{$pkg}{conflicts} =~ s/^, //;
      $pkgdata{$pkg}{conflicts} = expandmacros($pkgdata{$pkg}{conflicts},'gp');
    }

    # Gotta do this next, otherwise the control file has nowhere to go.  >:(
    mkdir "$buildroot/$pkg/DEBIAN";

    # Hack the filename for the package into a Debian-tool-compatible format.  GRRRRRR!!!!!
    # Have I mentioned I hate Debian Policy?
    $pkgdata{$pkg}{name} =~ tr/_/-/;

    # create script filename
    my $debscriptfile = "$tmpdir/deb-tmp.pkg.".int(rand(99998)+1);
    sysopen(DEBSCRIPT, $debscriptfile, O_RDWR | O_CREAT | O_EXCL | O_NOFOLLOW)
	or die $!;
    print DEBSCRIPT $scriptletbase;
    print DEBSCRIPT "fakeroot dpkg-deb -b $buildroot/$pkg $topdir/DEBS/$pkgdata{$pkg}{arch}/".
	"$pkgdata{$pkg}{name}_$pkgdata{$pkg}{version}-$pkgdata{main}{release}_$pkgdata{$pkg}{arch}.deb\n";
      # %$&$%@#@@#%@@@ Debian and their horrible ugly package names.  >:(
    close DEBSCRIPT;

    my $control = "Package: $pkgdata{$pkg}{name}\n".
	"Version: $pkgdata{$pkg}{version}-$pkgdata{main}{release}\n".
	"Section: $pkgdata{$pkg}{group}\n".
	"Priority: optional\n".
	"Architecture: $pkgdata{$pkg}{arch}\n".
	"Maintainer: $pkgdata{main}{packager}\n".
	( $pkgdata{$pkg}{requires} ne '' ? "Depends: $pkgdata{$pkg}{requires}\n" : '' ).
	( defined($pkgdata{$pkg}{provides}) ? "Provides: $pkgdata{$pkg}{provides}\n" : '' ).
	( defined($pkgdata{$pkg}{conflicts}) ? "Conflicts: $pkgdata{$pkg}{conflicts}\n" : '' ).
	"Description: $pkgdata{$pkg}{summary}\n";
    $control .= "$pkgdata{$pkg}{desc}\n";

    open CONTROL, ">$buildroot/$pkg/DEBIAN/control";
    print CONTROL $control;
    close CONTROL;

    # Iff there are conffiles (as specified in the %files list(s), add'em
    # in so dpkg-deb can tag them.
    if ($pkgdata{$pkg}{conffiles}) {
      open CONFLIST, ">$buildroot/$pkg/DEBIAN/conffiles";
      foreach my $conffile (@{$pkgdata{$pkg}{conflist}}) {
	print CONFLIST "$conffile\n";
      }
      close CONFLIST;
    }

    # found the point of scripts on subpackages.
    if ($pkgdata{$pkg}{'pre'}) {
      $pkgdata{$pkg}{'pre'} = expandmacros($pkgdata{$pkg}{'pre'},'gp');
      open PREINST, ">$buildroot/$pkg/DEBIAN/preinst";
      print PREINST "#!/bin/sh\nset -e\n\n";
      print PREINST $pkgdata{$pkg}{'pre'};
      close PREINST;
      `chmod 0755 $buildroot/$pkg/DEBIAN/preinst`;
    }
    if ($pkgdata{$pkg}{'post'}) {
      $pkgdata{$pkg}{'post'} = expandmacros($pkgdata{$pkg}{'post'},'gp');
      open PREINST, ">$buildroot/$pkg/DEBIAN/postinst";
      print PREINST "#!/bin/sh\nset -e\n\n";
      print PREINST $pkgdata{$pkg}{'post'};
      close PREINST;
      `chmod 0755 $buildroot/$pkg/DEBIAN/postinst`;
    }
    if ($pkgdata{$pkg}{'preun'}) {
      $pkgdata{$pkg}{'pre'} = expandmacros($pkgdata{$pkg}{'preun'},'gp');
      open PREINST, ">$buildroot/$pkg/DEBIAN/prerm";
      print PREINST "#!/bin/sh\nset -e\n\n";
      print PREINST $pkgdata{$pkg}{'preun'};
      close PREINST;
      `chmod 0755 $buildroot/$pkg/DEBIAN/prerm`;
    }
    if ($pkgdata{$pkg}{'postun'}) {
      $pkgdata{$pkg}{'postun'} = expandmacros($pkgdata{$pkg}{'postun'},'gp');
      open PREINST, ">$buildroot/$pkg/DEBIAN/postrm";
      print PREINST "#!/bin/sh\nset -e\n\n";
      print PREINST $pkgdata{$pkg}{'postun'};
      close PREINST;
      `chmod 0755 $buildroot/$pkg/DEBIAN/postrm`;
    }

    # execute
    print "Calling package creation script $debscriptfile for $pkgdata{$pkg}{name}...\n";
    system("/bin/sh -e $debscriptfile") == 0
	or die "Can't exec: $!\n";

    $finalmessages .= "Wrote binary package ".
	"$pkgdata{$pkg}{name}_$pkgdata{$pkg}{version}-$pkgdata{main}{release}_$pkgdata{$pkg}{arch}.deb".
	" in $topdir/DEBS/$pkgdata{$pkg}{arch}\n";
    # and clean up
    unlink $debscriptfile;

  } # subpackage loop

} # end binpackage()


## srcpackage()
# Builds a .src.deb source package.  Note that Debian's idea of
# a "source package" is seriously flawed IMO, because you can't
# easily copy it as-is.
# Not quite identical to RPM, but Good Enough (TM).
sub srcpackage {
  # In case we were called with -bs.
  $pkgdata{main}{name} =~ tr/_/-/;
  my $pkgsrcname = "$pkgdata{main}{name}-$pkgdata{main}{version}-$pkgdata{main}{release}.sdeb";

  my $paxcmd;

  # We'll definitely need this later, and *may* need it sooner.
  (my $barespec = $specfile) =~ s|.+/([^/]+)$|$1|;

  # Copy the specfile to the build tree, but only if it's not there already.
##buglet: need to deal with silly case where silly user has put the spec
# file in a subdir of %{_topdir}/SPECS.  Ewww.  Silly user!
  if (abs_path($specfile) !~ /^$topdir\/SPECS/) {
    $paxcmd .= "cp $specfile %{_topdir}/SPECS/; \n"
  }

  # use pax -w [file] [file] ... >outfile.sdeb
  $paxcmd = "cd $topdir; pax -w ";

# tweak source entry into usable form.  Need it locally somewhere along the line.
  (my $pkgsrc = $pkgdata{main}{source}) =~ s|.+/([^/]+)$|$1|;
  $paxcmd .= "SOURCES/$pkgsrc ";

  # create file list:  Source[nn], Patch[nn]
  foreach my $specbit (keys %{$pkgdata{main}} ) {
    next if $specbit eq 'source';
    $paxcmd .= "SOURCES/$pkgdata{main}{$specbit} " if $specbit =~ /^patch/;
##buglet: need to deal with case where patches are listed as URLs?
#  or other extended pathnames?  Silly !@$%^&!%%!%!! user!
  }

  foreach my $source (keys %{$pkgdata{sources}}) {
    $paxcmd .= "SOURCES/$pkgdata{sources}{$source} ";
  }

  # add the spec file, source package destination, and cd back where we came from.
  $paxcmd .= "SPECS/$barespec > $topdir/SDEBS/$pkgsrcname; cd -";

  # In case of %-macros...
  $paxcmd = expandmacros($paxcmd,'gp');
  
  system "$paxcmd";
  $finalmessages .= "Wrote source package $pkgsrcname in $topdir/SDEBS.\n";
}


## checkbuildreq()
# Checks the build requirements (if any)
# Spits out a rude warning and returns a true-false error if any
# requirements are not met.
sub checkbuildreq {
  return 1 if $buildreq eq '';	# No use doing extra work.

  if ( ! -e "/usr/bin/dpkg-query" ) {
    print "**WARNING**  dpkg-query not found.  Can't check build-deps.\n".
	"  Required for sucessful build:\n".$buildreq."\n".
	"  Continuing anyway.\n";
    return 1;
  }

  my $reqflag = 1;  # unset iff a buildreq is missing

  $buildreq =~ s/^, //;	# Strip the leading comma and space
  my @reqlist = split /,\s+/, $buildreq;

  foreach my $req (@reqlist) {
    my ($pkg,$rel,$ver);

    # We have two classes of requirements - versioned and unversioned.
    if ($req =~ /[><=]/) {
      # Pick up the details of versioned buildreqs
      ($pkg,$rel,$ver) = ($req =~ /([a-z0-9._-]+)\s+([><=]+)\s+([a-z0-9._-]+)/);
    } else {
      # And the unversioned ones.
      $pkg = $req;
      $rel = '>=';
      $ver = 0;
    }

    my @pkglist = qx { dpkg-query --showformat '\${status}\t\${version}\n' -W $pkg };
# need to check if no lines returned - means a bad buildreq
    my ($reqstat,undef,undef,$reqver) = split /\s+/, $pkglist[0];
    if ($reqstat !~ /install/) {
      print " * Missing build-dependency $pkg!\n";
      $reqflag = 0;
    } else {
# gotta be a better way to do this... :/
      if ($rel eq '>=' && !($reqver ge $ver)) {
	print " * Buildreq $pkg is installed, but wrong version ($reqver):  Need $ver\n";
	$reqflag = 0;
      }
      if ($rel eq '>' && !($reqver gt $ver)) {
	print " * Buildreq $pkg is installed, but wrong version ($reqver):  Need $ver\n";
	$reqflag = 0;
      }
      if ($rel eq '<=' && !($reqver le $ver)) {
	print " * Buildreq $pkg is installed, but wrong version ($reqver):  Need $ver\n";
	$reqflag = 0;
      }
      if ($rel eq '<' && !($reqver lt $ver)) {
	print " * Buildreq $pkg is installed, but wrong version ($reqver):  Need $ver\n";
	$reqflag = 0;
      }
      if ($rel eq '=' && !($reqver eq $ver)) {
	print " * Buildreq $pkg is installed, but wrong version ($reqver):  Need $ver\n";
	$reqflag = 0;
      }
    } # end not installed/installed check
  } # end req loop

  return $reqflag;
} # end checkbuildreq()


## getreqs()
# Find out which libraries/packages are required for any
# executables and libs in a given file tree.
# (Debian doesn't have soname-level deps;  just package-level)
# Returns an empty string if the tree contains no binaries.
# Doesn't work well on shell scripts. but those *should* be
# fine anyway.  (Yeah, right...)
sub getreqs() {
  my $pkgtree = $_[0];

  print "Checking library requirements...\n";
  my @binlist = qx { find $pkgtree -type f -perm 755 };

  if (scalar(@binlist) == 0) {
    return '';
  }

  my @reqlist;
  foreach (@binlist) {
    push @reqlist, qx { ldd $_ };
  }

  # Get the list of libs provided by this package.  Still doesn't
  # handle the case where the lib gets stuffed into a subpackage.  :/
  my @intprovlist = qx { find $pkgtree -type f -name "*.so*" };
  my $provlist = '';
  foreach (@intprovlist) {
    s/$pkgtree//;
    $provlist .= "$_";
  }

  my %reqs;
  my $reqlibs = '';

  foreach (@reqlist) {
    next if /^$pkgtree/;
    next if /not a dynamic executable/;
    next if m|/lib/ld-linux.so|;	# Hack! Hack!  PTHBTT!  (libc suxx0rz)

    my ($req) = (/^\s+([a-z0-9._-]+)/); # dig out the actual library (so)name

    # Ignore libs provided by this package.  Note that we don't match
    # on word-boundary at the *end* of the lib we're looking for, as the
    # looked-for lib may not have the full soname version. (ie, it may
    # "just" point to one of the symlinks that get created somewhere.)
    next if $provlist =~ /\b$req/;

    $reqlibs .= " $req";
  }

  if ($reqlibs ne '') {
    foreach (qx { dpkg -S $reqlibs }) {
      my ($libpkg,undef) = split /:\s+/;
      $reqs{$libpkg} = 1;
    }
  }

  my $deplist = '';
  foreach (keys %reqs) {
    $deplist .= ", $_";
  }

# For now, we're done.  We're not going to meddle with versions yet.
# Among other things, it's messier than handling "simple" yes/no "do
# we have this lib?" deps.  >:(

  return $deplist;
} # end getreqs()


## install_sdeb()
# Extracts .sdeb contents to %_topdir as appropriate
sub install_sdeb {
  $srcpkg = abs_path($srcpkg);

  my $paxcmd = "cd $topdir; pax -r <$srcpkg; cd -";

  # In case of %-macros...
  $paxcmd = expandmacros($paxcmd,'gp');
  
  system "$paxcmd";
  print "Extracted source package $srcpkg to $topdir.\n";
} # end install_sdeb()


## expandmacros()
# Expands all %{blah} macros in the passed string
# Split up a bit with some sections so we don't spend time trying to
# expand macros that are only used in a few specific places.
sub expandmacros {
  my $macrostring = shift;
  my $section = shift;

  # To allow the FHS-ish %configure and %makeinstall to work The Right Way.
  # (Without clobbering the global $buildroot.)
  my $prefix = '';

  if ($section =~ /c/) {
    # %configure macro
# Don't know what it's for, don't have a useful default replacement
# 	--program-prefix=%{_program_prefix} \
    $macrostring =~ s'%configure'./configure --host=$DEB_HOST_GNU_TYPE \
	--build=$DEB_BUILD_GNU_TYPE \
	--prefix=%{_prefix} \
	--exec-prefix=%{_exec_prefix} \
	--bindir=%{_bindir} \
	--sbindir=%{_sbindir} \
	--sysconfdir=%{_sysconfdir} \
	--datadir=%{_datadir} \
	--includedir=%{_includedir} \
	--libdir=%{_libdir} \
	--libexecdir=%{_libexecdir} \
	--localstatedir=%{_localstatedir} \
	--sharedstatedir=%{_sharedstatedir} \
	--mandir=%{_mandir} \
	--infodir=%{_infodir} ';
  } # done %configure

  if ($section =~ /m/) {
    $macrostring =~ s'%{__make}'make ';
  } # done make

  if ($section =~ /i/) {
    # This is where we need to mangle $prefix.
    $macrostring =~ s'%makeinstall'make %{fhs} install';
    $prefix = $buildroot;
  } # done %install and/or %makeinstall

  # Build data
  # Note that these are processed in reverse order to get the substitution order right
  if ($section =~ /b/) {
#    $macrostring =~ s'%{fhs}'host=$DEB_HOST_GNU_TYPE \
#	build=$DEB_BUILD_GNU_TYPE \
    $macrostring =~ s'%{fhs}'prefix=%{_prefix} \
	exec-prefix=%{_exec_prefix} \
	bindir=%{_bindir} \
	sbindir=%{_sbindir} \
	sysconfdir=%{_sysconfdir} \
	datadir=%{_datadir} \
	includedir=%{_includedir} \
	libdir=%{_libdir} \
	libexecdir=%{_libexecdir} \
	localstatedir=%{_localstatedir} \
	sharedstatedir=%{_sharedstatedir} \
	mandir=%{_mandir} \
	infodir=%{_infodir} \
';

    # Note that the above regex terminates with the extra space
    # "Just In Case" of user additions, which will then get neatly
    # tagged on the end where they take precedence (supposedly)
    # over the "default" ones.

    # Now we cascade the macros introduced above.  >_<
									# Wot ot to go theah:
    $macrostring =~ s|%{_mandir}|%{_datadir}/man|g;			#/usr/share/man
    $macrostring =~ s|%{_infodir}|%{_datadir}/info|g;			#/usr/share/info
    $macrostring =~ s|%{_oldincludedir}|/usr/include|g;		#/usr/include
    $macrostring =~ s|%{_includedir}|%{_prefix}/include|g;	#/usr/include
    $macrostring =~ s|%{_libdir}|%{_exec_prefix}/%{_lib}|g;	#/usr/lib
    $macrostring =~ s|%{_lib}|lib|g;					#?
    $macrostring =~ s|%{_localstatedir}|/var|g;			#/var
    $macrostring =~ s|%{_sharedstatedir}|%{_prefix}/com|g;	#/usr/com WTF?
    $macrostring =~ s|%{_sysconfdir}|/etc|g;			#/etc
    $macrostring =~ s|%{_datadir}|%{_prefix}/share|g;		#/usr/share
    $macrostring =~ s|%{_libexecdir}|%{_exec_prefix}/libexec|g;	#/usr/libexec
    $macrostring =~ s|%{_sbindir}|%{_exec_prefix}/sbin|g;	#/usr/sbin
    $macrostring =~ s|%{_bindir}|%{_exec_prefix}/bin|g;		#/usr/bin
    $macrostring =~ s|%{_exec_prefix}|%{_prefix}|g;		#/usr
    $macrostring =~ s|%{_prefix}|/usr|g;				#/usr
  } # done with config section

  # Package data
  if ($section =~ /p/) {
    $macrostring =~ s/\%\{buildroot\}/$buildroot/gi;
    foreach my $source (keys %{$pkgdata{sources}}) {
      $macrostring =~ s/\%\{source$source\}/$topdir\/SOURCES\/$pkgdata{sources}{$source}/gi;
    }
    $macrostring =~ s/\%\{name\}/$pkgdata{main}{name}/gi;
    $macrostring =~ s/\%\{version\}/$pkgdata{main}{version}/gi;
    $macrostring =~ s/\%\{release\}/$pkgdata{main}{release}/gi;
  }

  # Globals, and not-so-globals
  if ($section =~ /g/) {

    # special %define's.  Handle the general case where we eval anything.
    # Even more general:  %(...) is a spec-parse-time shell code wrapper.
    # Prime example:
    #%define perl_vendorlib %(eval "`perl -V:installvendorlib`"; echo $installvendorlib)
    if ($macrostring =~ /^\%\(.+\)$/) {
      $macrostring =~ s/^\%\(//;
      $macrostring =~ s/\)$//;
      # Oy vey this gets silly for the perl bits.  Executing a shell to
      # call Perl to get the vendorlib/sitelib/whatever "core" globals.
      # This can do more, but...  eww.
      # Next line is non-optimal - what if $macrostring contains ' characters?
      $macrostring = qx { /bin/sh -c '$macrostring' };
    }

    $macrostring =~ s|%{_builddir}|%{_topdir}/BUILD|g;
    $macrostring =~ s|%{_topdir}|$topdir|g;
    $macrostring =~ s|%{_tmppath}|$tmpdir|g;
    $macrostring =~ s'%{_docdir}'%{_datadir}/doc'g;

    # Standard FHS locations.  More or less.
    $macrostring =~ s'%{_bindir}'/usr/bin'g;
    $macrostring =~ s'%{_sbindir}'/usr/sbin'g;
    $macrostring =~ s'%{_mandir}'%{_datadir}/man'g;
    $macrostring =~ s'%{_includedir}'/usr/include'g;
    $macrostring =~ s'%{_libdir}'/usr/lib'g;
    $macrostring =~ s'%{_sysconfdir}'/etc'g;
    $macrostring =~ s'%{_localstatedir}'/var'g;

    # FHS-ish locations that aren't quite actually FHS-specified.
    $macrostring =~ s'%{_datadir}'/usr/share'g;

    # %define's
    foreach my $key (keys %specglobals) {
      $macrostring =~ s|%{$key}|$specglobals{$key}|g;
    }

    # system programs.  RPM uses a global config file for these;  we'll just
    # ASS-U-ME and make life a little simpler.
    if ($macrostring =~ /\%\{\_\_([a-z0-9_-]+)\}/) {
      $macrostring =~ s|%{__([a-z0-9_-]+)}|$1|g;
    }

    # Misc expansions
    $macrostring =~ s|%{_arch}|$hostarch|g;
    $macrostring =~ s|%{optflags}|$optflags{$hostarch}|g;

  } # done with globals section

  return $macrostring;
} # end expandmacros()



__END__



=head1 NAME

debbuild - Build Debian-compatible packages from RPM spec files

=head1 SYNOPSIS

 debbuild {-ba|-bb|-bp|-bc|-bi|-bl|-bs} [build-options] file.spec

 debbuild {-ta|-tb|-tp|-tc|-ti|-tl|-ts} [build-options] file.tar.{gz|bz2}

 debbuild --rebuild file.{src.rpm|sdeb}

 debbuild --showpkgs

=head1 DESCRIPTION

This script attempts to build Debian-friendly semi-native packages from RPM spec files, 
RPM-friendly tarballs, and RPM source packages (.src.rpm files).  It accepts I<most> of the 
options rpmbuild does, and should be able to interpret most spec files usefully.  Perl 
modules should be handled via CPAN+dh-make-perl instead;  Debian's conventions for such 
things do not lend themselves to automated conversion.

As far as possible, the command-line options are identical to those from rpmbuild, although 
several rpmbuild options are not supported:

 --recompile
 --showrc
 --buildroot
 --clean
 --nobuild
 --rmsource
 --rmspec
 --sign
 --target

Some of these could probably be trivially added.  Feel free to send me a patch.  ;)

Complex spec files will most likely not work well, if at all.  Rewrite them from scratch - 
you'll have to make heavy modifications anyway.

If you see something you don't like, mail me.  Send a patch if you feel inspired.  I don't 
promise I'll do anything other than say "Yup, that's broken" or "Got your message".

=head1 ASSUMPTIONS

As with rpmbuild, debbuild makes some assumptions about your system.

=over 4

=item *

Either you have rights to do as you please under /usr/src/debian, or you have created a file 
~/.debmacros containing a suitable %_topdir definition.

Both rpmbuild and debbuild require the directories %_topdir/{BUILD,SOURCES,SPECS}.  However, 
where rpmbuild requires the %_topdir/{RPMS,SRPMS} directories, debbuild  
requires %_topdir/{DEBS,SDEBS} instead.  Create them in advance;  
some subdirectories are created automatically as needed, but most are not.

=item *

/var/tmp must allow script execution - rpmbuild and debbuild both rely on creating and 
executing shell scripts for much of their functionality.  By default, debbuild also creates 
install trees under /var/tmp - however this is (almost) entirely under the control of the 
package's .spec file.

=item *
  
If you wish to --rebuild a .src.rpm, your %_topdir for both debbuild and rpmbuild must either 
match, or be suitably symlinked one direction or another so that both programs are effectively 
working in the same tree.  (Or you could just manually wrestle files around your system.)

You could symlink ~/.rpmmacros to ~/.debmacros (or vice versa) and save yourself some hassle 
if you need to rebuild .src.rpm packages on a regular basis.  Currently debbuild only uses the 
%_topdir macro definition, although there are many more things that rpmbuild can use from 
~/.rpmmacros.

=back

=head1 ERRATA

debbuild deliberately does a few things differently from rpm.

=head2 BuildArch or BuildArchitecture

rpm takes the last BuildArch entry it finds in the .spec file, whatever it is, and runs with 
that for all packages.  Debian's repository system is fairly heavily designed around the 
assumption that a single source package may generate small binary (executable) packages 
for each arch, and large binary arch-all packages containing shared data.

debbuild allows this by using the architecture specified by (in order of preference):

=over 4

=item * Host architecture

=item * BuildArch specified in .spec file preamble

=item * "Last specified" BuildArch for packages with several subpackages

=item * BuildArch specified in the %package section for that subpackage

=back

=head2 Finding out what packages should be built (--showpkgs)

rpmbuild does not include any convenient method I know of to list the packages a spec file 
will produce.  Since I needed this ability for another tool, I added it.

It requires the .spec file for the package, and produces a list of full package filenames 
(without path data) that would be generated by one of --rebuild, -ta, -tb, -ba, or -bb.  
This includes the .sdeb source package.

=head1 AUTHOR

debbuild was written by Kris Deugau <kdeugau@deepnet.cx>.  A version that approximates 
current is available at http://www.deepnet.cx/debbuild/.

=head1 BUGS

Funky Things Happen if you forget a command-line option or two.  I've been too lazy to bother 
fixing this.

Many macro expansions are unsupported or incompletely supported.

The generated scriptlets don't quite match those from rpmbuild exactly.  There are extra 
environment variables and preprocessing that I haven't needed (yet).

Dcumentation, such as it is, will likely remain perpetually out of date.

%_topdir and the five "working" directories under %_topdir could arguably be created by 
debbuild.  However, rpmbuild doesn't create these directories either.

=head1 SEE ALSO

rpm(8), rpmbuild(8), and pretty much any document describing how to write a .spec file.

=cut
