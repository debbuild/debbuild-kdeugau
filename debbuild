#!/usr/bin/perl
# debbuild script
# Shamlessly steals intreface from rpm's "rpmbuild" to create
# Debian packages.  Please note that such packages are highly
# unlikely to conform to "Debian Policy".
###
# SVN revision info
# $Date$
# SVN revision $Rev$
# Last update by $Author$
###

# Program flow:
# -> Parse/execute "system" config/macros (if any - should be rare)
# -> Parse/execute "user" config/macros (if any - *my* requirement is %_topdir)
# -> Parse command line for options, spec file/tarball/.src.deb (NB - also accept .src.rpm)

# User's prefs for dirs, environment, etc,etc,etc.
# config file ~/.debmacros
# Default ordered search paths for config/macros:
# /usr/lib/rpm/rpmrc  /usr/lib/rpm/redhat/rpmrc  /etc/rpmrc      ~/.rpmrc
# /usr/lib/rpm/macros /usr/lib/rpm/redhat/macros /etc/rpm/macros ~/.rpmmacros
# **NOTE:  May be possible to (ab)use bits of debhelper

# Build tree
# default is /usr/src/debian/{BUILD,SOURCES,SPECS,DEBS,SDEBS}

# Globals
my $specfile;
my $tarball;
my $srcpkg;
my $verbosity = 0;
my %cmdopts = (type => '',
		stage => 'a',
		short => 'n'
	);
my %targets = ('p' => 'Prep',
		'c' => 'Compile',
		'i' => 'Install',
		'l' => 'Verify %files',
		'a' => 'Build binary and source',
		'b' => 'Build binary',
		's' => 'Build source'
	);
my $topdir = "/usr/src/debian";

load_userconfig();
parse_cmd();

# Hokay.  Need to:
# Execute prep if *not* --short-circuit
prep() if ($cmdopts{short} ne 'y');

if ($cmdopts{stage} =~ /ciab/) {
  # Execute build if bc
  # Execute build if bi, ba, bb and NOT --short-circuit
  build() if ( ($cmdopts{stage} eq 'c') ||
	(($cmdopts{stage} =~ /iab/) && ($cmdopts{short} ne 'y'))
	);

  # -> Execute 
  install() if ($cmdopts{short} ne 'y');
  binpackage();
}

srcpackage();



# Just in case.
exit 0;


## load_userconfig()
# Loads user configuration (if any)
# Currently only handles .debmacros
# Needs to handle "other files"
sub load_userconfig {
  (undef,undef,undef,undef,undef,undef,undef,$homedir,undef) = getpwuid($<);
  if (-e "$homedir/.debmacros") {
    open USERMACROS,"<$homedir/.debmacros";
    while (<USERMACROS>) {
      # And we also only handle the %_topdir macro at the moment.
      if (/^\%_topdir/) {
	(undef,$tmp) = split /\s+/, $_;
      }
    }
  }
} # end load_userconfig()


## parse_cmd()
# Parses command line into global hash %cmdopts, other globals
# Options based on rpmbuild's options
sub parse_cmd {
  # Don't feel like coding my own option parser...
  #use Getopt::Long;
  # ... but I may have to:  (OTOH, rpm uses popt, so maybe we can too.)
  #use Getopt::Popt qw(:all);
  # Or not.  >:(  Stupid Debian lack of findable Perl module names in packages.

  # Stuff it.
  my $prevopt = '';
  foreach (@ARGV) {
    chomp;
    $prevopt = $_;
    # Is it an option?
    if (/^-/) {
      # Is it a long option?
      if (/^--/) {
	if (/^--short-circuit/) {
	  $cmdopts{short} = 'y';
	} else {
	  print "Long opt $_\n";
	}
      } else {
	if (/^-[bts]/) {
	  ($cmdopts{stage}) = (/^-[bts]([pcilabs])/);
	  ($cmdopts{type}) = (/^-([bts])[pcilabs]/);
	} elsif (/^-v/) {
	  # bump verbosity.  Not sure what I'll actually do here...
	} else {
	  die "Bad option $_\n";
	}
      }
    } else {
      print "Non-option arg $_\n";
    }
  }

  # Some cross-checks.  rpmbuild limits --short-circuit to just
  # the "compile" and "install" targets - with good reason IMO.
  # NB - this is NOT fatal, just ignored!
  if ($cmdopts{short} eq 'y') {
    warn "Can't use --short-circuit for $targets{$cmdopts{stage}} stage.  Ignoring.\n";
    $cmdopts{short} = 'n';
  }
  # Valid options, with example arguments (if any):
# Build from .spec file; mutually exclusive:
  # -bp
  # -bc         
  # -bi         
  # -bl
  # -ba
  # -bb
  # -bs
# Build from tarball; mutually exclusive:
  # -tp
  # -tc
  # -ti
  # -ta
  # -tb
  # -ts
# Build from .src.(deb|rpm)
  # --rebuild
  # --recompile

# General options
  # --buildroot=DIRECTORY
  # --clean
  # --nobuild
  # --nodeps
  # --nodirtokens
  # --rmsource
  # --rmspec
  # --short-circuit
  # --target=CPU-VENDOR-OS

  #my $popt = new Getopt::Popt(argv => \@ARGV, options => \@optionsTable);

} # end parse_cmd()


## prep()
# Unpacks the tarball from the SOURCES directory to the BUILD directory.
# Speaks gzip and bzip2.
# Requires the "package name"
# Finishes by applying patches in %prep section of spec file
sub prep {
  my $pkgname = shift;
  
} # end prep()


sub build {}
sub install {}
sub binpackage {}
sub srcpackage {}
